// Changes XML to JSON

var concatChar = ';';
var statData;
var coordArray;

function readStats()
{
	var transfer = Tundra.asset.requestAsset("http://localhost:8082/data/pno_tilasto_2015_evesav.csv", "Text");
	transfer.onCompleted(this, function(asset)
	{
		statData=generateArraysStats(asset.data);
		console.log("done parsing");
		coordArray=getcoordinateArraysStats(statData);
		console.log("done extracting coordinates")

	});
	transfer.onFailed(this, function(transfer, reason, metadata)
	{
		console.log("Failed", transfer, reason, metadata);
	})
	return coordArray;
}

function getcoordinateArraysStats(data)
{

	var coordArray=[];
	

	for (index = 0; index < data.length; ++index) 
	{


		var subArray=data[index];

			var subCoordArray=[];

			for (i = 0; i < subArray.length; ++i) 
			{

				if(i>=113)
				{
					//split easting and northing...
					var converted=subArray[i].replace(/[|&;$%@"<>()+]/g, "").split(' ')
						
						//send to transform function and add to coordArray
						subCoordArray.push(transformETRStoWGS84(converted) );
	
				}
			
			}
	
			coordArray[index]=subCoordArray;
     
	}

	console.log('coordArrays done');

	return coordArray;

}

 function transformETRStoWGS84(point) {
    Proj4js.defs["EPSG:3067"] = "+proj=utm +zone=35 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs";
	Proj4js.defs["EPSG:4326"] = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs";

    var pointObj = new Proj4js.Point(point[0], point[1]); //Note the order
    var source_kohteet = new Proj4js.Proj('EPSG:3067');
    var dest_google = new Proj4js.Proj('EPSG:4326'); //dest_WGS84
    Proj4js.transform(source_kohteet, dest_google, pointObj);

    return [pointObj['y'],pointObj['x']];
} 


function generateArraysStats(data)
{

	console.log('generating arrays');
	var finalArray=[];
	var tempArray=[];
	var lines = data.split('\n');

	for(var i = 0;i < lines.length;i++)
	{

		var firstPartofLine=[];
		var coordinates=[];

	    //code here using lines[i] which will give you each line
		var line=lines[i].split('MULTIPOLYGON ');

		for(var j = 0; j < line.length;j++)
		{
			//code here using lines[i] which will give you each line
			//if basic data
			if(j==0)
			{
				//console.log('data');
				//console.log(line[i]);
				firstPartofLine=line[j].split(',');
				//console.log(firstPartofLine);
			}
			//else if polygon aka 
			else
			{
				//console.log('coords');
				//console.log(line[i]);
				
				coordinates=line[j].replace(/[|&;$%@"<>()+]/g, "").split(', ');

				//console.log(coordinates);
			}

		}

		tempArray=firstPartofLine.concat(coordinates);
		//console.log(tempArray);
		if(tempArray.length > 1){
			finalArray.push(tempArray);
		}

		
	}

	console.log('finalArray done');

	return finalArray;

}

function xmlToJson(xml) 
{
    
    // Create the return object
    var obj = {};

    if (xml.nodeType == 1) { // element
        // do attributes
        if (xml.attributes.length > 0) {
        obj["@attributes"] = {};
            for (var j = 0; j < xml.attributes.length; j++) {
                var attribute = xml.attributes.item(j);
                obj["@attributes"][attribute.nodeName] = attribute.nodeValue;
            }
        }
    } else if (xml.nodeType == 3) { // text
        obj = xml.nodeValue;
    }

    // do children
    if (xml.hasChildNodes()) {
        for(var i = 0; i < xml.childNodes.length; i++) {
            var item = xml.childNodes.item(i);
            var nodeName = item.nodeName;
            if (typeof(obj[nodeName]) == "undefined") {
                obj[nodeName] = xmlToJson(item);
            } else {
                if (typeof(obj[nodeName].push) == "undefined") {
                    var old = obj[nodeName];
                    obj[nodeName] = [];
                    obj[nodeName].push(old);
                }
                obj[nodeName].push(xmlToJson(item));
            }
        }
    }
    return obj;
};

function drawBoundary(coordinates)
{

	if ( coordinates == null) {
		console.log("coordinates are not given");
		coordinates = [ {lat: 65.015709, lon: 25.470789}, {lat: 65.016709,lon: 25.470089}, {lat: 65.017709,lon: 25.471789}, {lat: 65.016709,lon: 25.472789}, {lat: 65.015709, lon: 25.470789} ];
	}
	// Remove the previous route
	//Tundra.renderer.scene.remove( this.highlighted_route );
	
	var line_material = new THREE.LineBasicMaterial({
		color: 0xFF0000,
		linewidth: 100
		});
		
	var line_geometry = new THREE.Geometry();

	for (var i = 0; i < coordinates.length; i++) {
		for (var j = 0; j < coordinates[i].length; j++) {
			var lat = coordinates[i][j][0];
			var lon = coordinates[i][j][1];
			var pos = Tundra.plugins.meshmoonGeo.coordinates.latLonToWorldPosition(lat, lon);
			// height of the line from the ground
			pos.y = 25;
			line_geometry.vertices.push(pos);
		}
	}
	var line = new THREE.Line( line_geometry, line_material );
	this.highlighted_route = line;
	Tundra.renderer.scene.add( this.highlighted_route );
}

function getCoordinate()
{
    var r = Tundra.renderer.raycast(undefined, undefined, 0, undefined, true);
		//console.log("vec_cor:", r.pos);
	console.log("vec_cor", r.pos);
	var cor_array = Tundra.plugins.meshmoonGeo.coordinates.worldPositionToLatLon(r.pos.x, r.pos.y);
	//console.log(cor_array.lat, cor_array.lon);
	return cor_array
}

var WebRocketApplication = IApplication.$extend(
{
	//debugger;
    __init__ : function()
    {
        this.$super("Meshmoon GEO");

        this.data = {};

        this.timing = new AsyncHelper(this.name, this);
        this.state =
        {
            camera : {}
        };

		$.getScript( "http://svn.osgeo.org/metacrs/proj4js/branches/proj4js-1.0/lib/proj4js-combined.js" )
			.done(function( script, textStatus ) {
				console.log("Proj4js.js included" );
				coordArray = readStats();
				
			})
			.fail(function( jqxhr, settings, exception ) {
			console.log("++++++++++++++++++++++++++FAILED");	
		});

        // Monitor active camera change
        var activeCamera = Tundra.renderer.activeCameraEntity();
        if (activeCamera != null && activeCamera.camera != null)
            this.onActiveCameraChanged(activeCamera.camera);

        this.subscribeEvent(Tundra.renderer.onActiveCameraChanged(this, this.onActiveCameraChanged));

        // Run RTS camera application
        this.rts = {};
        this.rts.ent = Tundra.client.runApplication("RTS", "meshmoon-applications://meshmoon/rts-camera/rts-camera.webrocketjs");
        this.rts.ent.script.onScriptStarted(function(entity, component, scriptAsset, app) {
            this.rts.app = app;
        }.bind(this));

        // You can turn on debugging to see more internals
        //Tundra.plugins.meshmoonGeo.config.debug = true; // and/or
        //Tundra.plugins.meshmoonGeo.config.debugVolume = true;
        
        /* Run Meshmoon GEO at Oulu city center
           You can change this coordinate to be anywhere in the world
           and Meshmoon GEO will do its best to visualize the location. */
        Tundra.plugins.meshmoonGeo.start({
            lon : 25.466228,
            lat : 65.013439
        });

        // Setup default environment
        Tundra.plugins.meshmoonGeo.setupEnvironment();



        this.subscribeEvent(Tundra.input.onMousePress(this, this.onMousePress));

		
		IApplication.loadDependencies(this,
            "button1.html"
        ).done(this.initPolymer.bind(this));
	},

	initPolymer: function()
	{
		var element = document.createElement("alpha-element");
		Tundra.ui.add(element);
		
		element.name = "information 1";
		element.position = "ioformation 2";
		element.time = "information 3";
	},
	

    onMousePress: function(event)
    {
		console.log("coordinates", coordArray)
		var cor_array = getCoordinate();
		console.log(cor_array.lat, cor_array.lon);
		console.log("length = ", coordArray.length);
		drawBoundary(coordArray);

    },

    onActiveCameraChanged : function(activeCameraComponent, prevCameraComponent)
    {
        var cameraName = (activeCameraComponent.parentEntity ? activeCameraComponent.parentEntity.name : "");
        if (cameraName === "" || !cameraName)
            return;

        // Adjust far plane to handle big scene for Meshmoon GEO functionality
        this.camera = activeCameraComponent.parentEntity;
        this.camera.camera.farPlane = 1000000;

        this.log.debug("Active camera changed", this.camera.name);

        // If RTS camera execute configuration
        if (this.camera.name === "MeshmoonRtsCamera" && this.state.camera.configured === undefined)
        {
            this.state.camera.configured = true;
            this.timing.async("rts.config", function() {
                this.camera.exec(EntityAction.Local, "SetRotation", { x : -40, y : 0, z : 0 });
                this.camera.exec(EntityAction.Local, "SetDistance", 3000);
                this.camera.exec(EntityAction.Local, "SetMinDistance", 200);
                this.camera.exec(EntityAction.Local, "SetMaxDistance", this.camera.camera.farPlane * 0.4);
            }, 100);
        }
    },

    /** 
        Script destroy/unload handler. Called automatically 
        by the framework when the application is closed.
    */
    onScriptDestroyed : function()
    {
        Tundra.plugins.meshmoonGeo.stop();
    }
});

// Start the application by instantiating it
var webRocketApplication = new WebRocketApplication();